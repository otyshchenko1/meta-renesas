From 60e7e3c6b42316c4d24f38d0a6c36cd2cfa63764 Mon Sep 17 00:00:00 2001
From: Iurii Konovalenko <iurii.konovalenko@globallogic.com>
Date: Wed, 5 Nov 2014 18:25:55 +0200
Subject: [PATCH 15/18] arm: rmobile: Add support of starting CPUs in
 Hypervisor mode for Lager board

To start Xen hypervisor, CPUs must be swithced to hypervisor mode in u-boot.
For this purpose lager_xen_defconfig is provided.
In this configuration, virtual extension support is swithced on.
Also some changes, that are needed for successful Xen start, are provided.

Change-Id: I1d41d86822866246944d0a9fa65f59e53f2ee9d6
Signed-off-by: Iurii Konovalenko <iurii.konovalenko@globallogic.com>

Backport the patch.

Signed-off-by: Andrii Anisov <andrii.anisov@gmail.com>
---
 board/renesas/lager/lager.c | 156 ++++++++++++++++++++++++++++++++++++++++++++
 boards.cfg                  |   1 +
 include/configs/lager.h     |  13 +++-
 3 files changed, 169 insertions(+), 1 deletion(-)

diff --git a/board/renesas/lager/lager.c b/board/renesas/lager/lager.c
index 9268f87..515b09e 100644
--- a/board/renesas/lager/lager.c
+++ b/board/renesas/lager/lager.c
@@ -364,3 +364,159 @@ void arch_preboot_os()
 		       mstptbl[i].r_addr);
 	}
 }
+
+#ifdef CONFIG_ARMV7_VIRT
+extern void shmobile_boot_vector(void);
+extern unsigned long shmobile_boot_size;
+
+#define r8a7790_clst_id(cpu) ((cpu & 4) > 0 ? 1 : 0)
+#define r8a7790_cpu_id(cpu) ((cpu) & 0x3)
+#define LAGER_APMU_BASE                        0xE6150000
+#define LAGER_APMU_CA15WUPCR_OFFSET            0x2010
+#define LAGER_APMU_CA15CPUCMCR_OFFSET          0x2184
+#define LAGER_APMU_CA7WUPCR_OFFSET             0x1010
+#define LAGER_APMU_CA7CPUCMCR_OFFSET           0x1184
+#define LAGER_RST_BASE                         0xE6160000
+#define LAGER_RST_CA15BAR_OFFSET               0x20
+#define LAGER_RST_CA7BAR_OFFSET                0x30
+#define LAGER_RST_CA15BAR_BAREN                (1 << 4)
+#define LAGER_RST_CA7BAR_BAREN                 (1 << 4)
+#define LAGER_RST_CA15RESCNT_OFFSET            0x40
+#define LAGER_RST_CA7RESCNT_OFFSET             0x44
+#define		BIT(x)	(1 << (x))
+#define LAGER_XEN_INIT_SECONDARY_START         0xE63C0FFC
+#define LAGER_RST_BASE                         0xE6160000
+#define LAGER_RST_CA15BAR                      0xE6160020
+#define LAGER_RST_CA7BAR                       0xE6160030
+#define LAGER_LAGER_RAM                        0xE63C0000
+#define LAGER_MAX_CPUS                         4
+
+
+enum { R8A7790_CLST_CA15, R8A7790_CLST_CA7, R8A7790_CLST_NR };
+static struct {
+	unsigned int wupcr;
+	unsigned int bar;
+	unsigned int rescnt;
+	unsigned int rescnt_magic;
+} r8a7790_clst[R8A7790_CLST_NR] = {
+	[R8A7790_CLST_CA15] = {
+		.wupcr = LAGER_APMU_CA15WUPCR_OFFSET,
+		.bar = LAGER_RST_CA15BAR_OFFSET,
+		.rescnt = LAGER_RST_CA15RESCNT_OFFSET,
+		.rescnt_magic = 0xa5a50000,
+},
+	[R8A7790_CLST_CA7] = {
+		.wupcr = LAGER_APMU_CA7WUPCR_OFFSET,
+		.bar = LAGER_RST_CA7BAR_OFFSET,
+		.rescnt = LAGER_RST_CA7RESCNT_OFFSET,
+		.rescnt_magic = 0x5a5a0000,
+	},
+};
+
+static void assert_reset(unsigned int cpu)
+{
+	void *rescnt;
+	u32 mask, magic;
+	unsigned int clst_id = r8a7790_clst_id(cpu);
+
+	/* disable per-core clocks */
+	mask = BIT(3 - r8a7790_cpu_id(cpu));
+	magic = r8a7790_clst[clst_id].rescnt_magic;
+	rescnt = (void *) (LAGER_RST_BASE + r8a7790_clst[clst_id].rescnt);
+	writel((readl(rescnt) | mask) | magic, rescnt);
+}
+
+static void deassert_reset(unsigned int cpu)
+{
+	void *rescnt;
+	u32 mask, magic;
+	unsigned int clst_id = r8a7790_clst_id(cpu);
+
+	/* enable per-core clocks */
+	mask = BIT(3 - r8a7790_cpu_id(cpu));
+    magic = r8a7790_clst[clst_id].rescnt_magic;
+	rescnt = (void *) (LAGER_RST_BASE + r8a7790_clst[clst_id].rescnt);
+	writel((readl(rescnt) & ~mask) | magic, rescnt);
+}
+
+static void power_on(unsigned int cpu)
+{
+	void *cawupcr;
+	unsigned int clst_id = r8a7790_clst_id(cpu);
+
+	cawupcr = (void *) (LAGER_APMU_BASE + r8a7790_clst[clst_id].wupcr);
+	writel(BIT(r8a7790_cpu_id(cpu)), cawupcr);
+
+	/* wait for APMU to finish */
+	while (readl(cawupcr) != 0);
+}
+
+void smp_kick_all_cpus(void)
+{
+	int i;
+	for (i = 1; i < LAGER_MAX_CPUS; i++)
+	{
+		assert_reset(i);
+		power_on(i);
+		deassert_reset(i);
+	}
+}
+
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+
+	void __iomem *p;
+	unsigned long *f;
+	unsigned long bar;
+
+	p = (void __iomem*) LAGER_LAGER_RAM;
+	memcpy (p, shmobile_boot_vector, shmobile_boot_size);
+	f = (void __iomem *)((long unsigned)p + shmobile_boot_size - 4);
+	*((unsigned long *) f) = addr;
+	dmb(); /* make sure we have finished io operations */
+
+	bar = (LAGER_LAGER_RAM >> 8) & 0xfffffc00;
+
+	writel(bar, LAGER_RST_CA15BAR);
+	writel(bar | 0x10, LAGER_RST_CA15BAR);
+	writel(bar, LAGER_RST_CA7BAR);
+	writel(bar | 0x10, LAGER_RST_CA7BAR);
+
+	f = (unsigned long *)(LAGER_XEN_INIT_SECONDARY_START);
+	*f = 0;
+
+	/* make sure this write is really executed */
+	__asm__ volatile ("dsb\n");
+}
+
+
+asm(".arm \n"
+	".align 2 \n"
+	".global smp_waitloop \n"
+	"smp_waitloop: \n"
+	"1: 	wfe \n"
+	"ldr 	r0, =0xE63C0FFC \n"
+	"ldr	r0, [r0] \n"
+	"teq	r0, #0x0 \n"
+	"beq 	1b \n"
+
+	"b		_do_nonsec_entry \n"
+	".type smp_waitloop, %function \n"
+	".size smp_waitloop, .-smp_waitloop \n");
+
+asm(
+	".arm \n"
+	".globl shmobile_boot_vector \n"
+	".align 2 \n"
+	"shmobile_boot_vector: \n"
+	"ldr    pc, 1f \n"
+	".type shmobile_boot_vector, %function \n"
+	".size shmobile_boot_vector, .-shmobile_boot_vector \n"
+    ".align	2 \n"
+		"func:\n"
+"1:	.space	4 \n"
+	".globl	shmobile_boot_size \n"
+"shmobile_boot_size: \n"
+	".long	.-shmobile_boot_vector \n");
+#endif
+
diff --git a/boards.cfg b/boards.cfg
index 752182f..0ea1c38 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -301,6 +301,7 @@ lager_extram                 arm         armv7       lager               renesas
 lager_media                  arm         armv7       lager               renesas        rmobile     lager:QOS_PRI_MEDIA
 lager_gfx                    arm         armv7       lager               renesas        rmobile     lager:QOS_PRI_GFX
 lager_vin                    arm         armv7       lager               renesas        rmobile     lager:QOS_PRI_VIN
+lager_virt                   arm         armv7       lager               renesas        rmobile     lager:ARMV7_VIRT
 koelsch                      arm         armv7       koelsch             renesas        rmobile     koelsch:QOS_PRI_NORMAL
 koelsch_extram               arm         armv7       koelsch             renesas        rmobile     koelsch:EXTRAM_BOOT,QOS_PRI_VIN
 koelsch_media                arm         armv7       koelsch             renesas        rmobile     koelsch:QOS_PRI_MEDIA
diff --git a/include/configs/lager.h b/include/configs/lager.h
index 1492de9..ac3f6b1 100644
--- a/include/configs/lager.h
+++ b/include/configs/lager.h
@@ -27,9 +27,15 @@
 #define CONFIG_RMOBILE
 #define CONFIG_RMOBILE_BOARD_STRING "Lager Board\n"
 #define CONFIG_SH_GPIO_PFC
+#ifndef CONFIG_ARMV7_VIRT
 #define CONFIG_SYS_THUMB_BUILD
+#endif
 #define CONFIG_MACH_LAGER
 
+#ifdef CONFIG_ARMV7_VIRT
+#define CONFIG_ARM_GIC_BASE_ADDRESS	0xf1000000
+#endif
+
 #include <asm/arch/rmobile.h>
 
 #define	CONFIG_CMD_EDITENV
@@ -90,7 +96,12 @@
 /* MEMORY */
 #define LAGER_SDRAM_BASE	0x40000000
 #define LAGER_SDRAM_SIZE	0x80000000
-#define LAGER_UBOOT_SDRAM_SIZE	0x20000000
+#ifndef CONFIG_ARMV7_VIRT
+#define LAGER_UBOOT_SDRAM_SIZE	0x20000000 /*512 MB*/
+#else
+#define LAGER_UBOOT_SDRAM_SIZE	0x40000000 /*1 GB*/
+#endif
+
 
 #define CONFIG_SYS_LONGHELP
 #define CONFIG_SYS_PROMPT		"=> "
-- 
2.7.4

